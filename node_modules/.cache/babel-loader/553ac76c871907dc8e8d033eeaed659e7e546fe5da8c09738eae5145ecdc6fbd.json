{"ast":null,"code":"// yarn add qrcode 执行命令安装\nimport QRCode from \"qrcode\";\n// yarn add html2canvas@1.0.0-rc.4 执行命令安装\nimport html2canvas from \"html2canvas\";\nexport default {\n  data() {\n    return {\n      url: \"\",\n      // 这个是输入框的值\n      qrCode: \"\",\n      // 这个是二维码图片的url\n      base64Image: \"\" // 这个是保存图片和复制图片使用的base64图片地址\n    };\n  },\n  methods: {\n    // 将页面内容生成图片的逻辑\n    generateimages() {\n      // 获取容器元素\n      const container = document.querySelector(\".container\");\n      const that = this;\n      // 使用 html2canvas 生成图片\n      return html2canvas(container, {\n        useCORS: true,\n        // 开启跨域配置\n        allowTaint: false,\n        // 允许跨域图片\n        scale: 2,\n        // 按比例增加分辨率 (2=双倍).\n        dpi: window.devicePixelRatio * 2,\n        // 设备像素比\n        height: document.querySelector('.container').clientHeight + 3 // 预防生成的图片截图不全的问题(例如加填充,边框等,就会导致截图不全,这样适当给截图区域加一点距离)\n      }).then(canvass => {\n        // 在canvas上添加文字内容准备\n        const title = \"萧寂\";\n        const title2 = \"萧寂的文件分享\";\n        const title3 = \"有效期至: 2024/04/08 23:59:59\";\n\n        // 创建画布\n        const canvas = document.createElement(\"canvas\");\n\n        // 设置 Canvas 元素的宽度和高度,与生成的canvas宽高一致\n        canvas.width = canvass.width;\n        canvas.height = canvass.height;\n\n        // 获取 Canvas 的 2D 绘图上下文\n        const ctx = canvas.getContext(\"2d\");\n        // 设置背景颜色为白色\n        ctx.fillStyle = \"#FFFFFF\";\n        // 创建白色块,宽高等于1画布的宽高\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        // 设置圆形的中心位置(x和y轴)\n        var centerX = canvas.width / 2;\n        var centerY = 40;\n\n        // 设置圆形的半径\n        var radius = 30;\n\n        // 绘制圆形\n        ctx.beginPath();\n        // (参数:中心点横坐标,中心点纵坐标,半径,路径(这里是2π代表整个圆),顺时针还是逆时针(由于是一整个圆,就不区分顺时针和逆时针了))\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, false);\n        // 圆的填充颜色\n        ctx.fillStyle = \"blue\";\n        ctx.fill();\n\n        // 创建一个图片对象\n        const image = new Image();\n        // 图片对象的src指向生成的图片的base64字符串,通过canvass.toDataURL()获得\n        image.src = canvass.toDataURL();\n\n        // 这里使用了promise,预防异步\n        return new Promise((resolve, reject) => {\n          // 等图片加载完毕\n          image.onload = function () {\n            // 下面三个是获取三个文字的宽\n            const titleWidth = ctx.measureText(title).width;\n            const titleWidth2 = ctx.measureText(title2).width;\n            const titleWidth3 = ctx.measureText(title3).width;\n            // 在 Canvas 上绘制图片(每个参数含义(图片源,横坐标,纵坐标,宽,高))\n            ctx.drawImage(image, canvas.width / 2 - canvas.width / 4 + 5, canvas.height / 2 - canvas.height / 4 + 50, canvas.width / 2, canvas.height / 2);\n\n            // 绘制其他内容\n            ctx.fillStyle = \"#FFFFFF\"; // 指定文字颜色\n            ctx.font = \"16px Arial\"; // 指定文字字号大小(只需要改前面的数字就行)\n\n            // !!!!注意,下面的文字理论可以通过canvas.width / 2 - titleWidth/ 2直接定位到水平中间的,但是如果画布内容有html内容则也会有影响的,因此这里需要手动调整\n            // 将文字定位到指定位置(参数(文字,横坐标,纵坐标))\n            ctx.fillText(title, canvas.width / 2 - titleWidth / 2 - 6, 45);\n\n            // 指定第二个文字的位置和颜色\n            ctx.fillStyle = \"#000000\"; // 指定文字颜色\n            ctx.font = \"20px Arial\";\n            ctx.fillText(title2, canvas.width / 2 - titleWidth2, 100);\n\n            // 指定第三个文字的位置和颜色\n            ctx.fillStyle = \"#000000\"; // 指定文字颜色\n            ctx.font = \"13px Arial\";\n            ctx.fillText(title3, canvas.width / 2 - titleWidth3 / 2 - 20, 130);\n\n            // 将 Canvas 转换为 base64 图片并保存\n            console.log(\"canvas.toDataURL()\", canvas.toDataURL());\n            that.base64Image = canvas.toDataURL();\n\n            // 操作完成，resolve Promise\n            resolve(\"完成\");\n          };\n          image.onerror = function (error) {\n            // 操作失败，reject Promise\n            reject(error);\n          };\n        });\n      }).catch(error => {\n        console.error(\"生成图片出错：\", error);\n        throw error;\n      });\n    },\n    generateQRCode() {\n      // 生成二维码逻辑(参数指定url文字即可)\n      QRCode.toDataURL(this.url).then(async qr => {\n        this.qrCode = qr;\n        // 生成完二维码重新对容器的内容进行图片的生成\n        // 这里会有异步情况,建议等一会\n        setTimeout(() => {\n          this.generateimages();\n        }, 1000);\n      }).catch(error => {\n        console.error(\"生成二维码出错：\", error);\n      });\n    },\n    saveImage() {\n      // 保存图片功能\n      // 创建一个虚拟的链接元素\n      const link = document.createElement(\"a\");\n      // 指定a元素href地址(指向base64图片)\n      link.href = this.base64Image;\n      // 下载图片的图片名后缀\n      link.download = \"image.png\";\n\n      // 使用点击事件模拟下载操作\n      link.dispatchEvent(new MouseEvent(\"click\"));\n    },\n    copyImage() {\n      // 实现复制图片到剪贴板的逻辑\n      // 创建一个Image元素并设置src为base64图片\n      const image = new Image();\n      image.src = this.base64Image;\n      console.log(\"复制的图片为:\", this.base64Image);\n      // 等待图片加载完成\n      image.onload = () => {\n        // 创建一个canvas元素\n        const canvas = document.createElement(\"canvas\");\n        // 获取canvas上下文对象\n        const ctx = canvas.getContext(\"2d\");\n\n        // 设置canvas的尺寸与图片一致\n        canvas.width = image.width;\n        canvas.height = image.height;\n\n        // 将图片绘制到canvas上\n        ctx.drawImage(image, 0, 0, image.width, image.height);\n\n        // 调用Clipboard API将canvas内容复制到剪贴板\n        canvas.toBlob(blob => {\n          const item = new ClipboardItem({\n            \"image/png\": blob\n          });\n          navigator.clipboard.write([item]).then(() => {\n            console.log(\"图片已复制到剪贴板\");\n          }).catch(err => {\n            console.error(\"复制图片失败:\", err);\n          });\n        });\n      };\n      image.onerror = err => {\n        console.error(\"图片加载失败:\", err);\n      };\n    }\n  }\n};","map":{"version":3,"names":["QRCode","html2canvas","data","url","qrCode","base64Image","methods","generateimages","container","document","querySelector","that","useCORS","allowTaint","scale","dpi","window","devicePixelRatio","height","clientHeight","then","canvass","title","title2","title3","canvas","createElement","width","ctx","getContext","fillStyle","fillRect","centerX","centerY","radius","beginPath","arc","Math","PI","fill","image","Image","src","toDataURL","Promise","resolve","reject","onload","titleWidth","measureText","titleWidth2","titleWidth3","drawImage","font","fillText","console","log","onerror","error","catch","generateQRCode","qr","setTimeout","saveImage","link","href","download","dispatchEvent","MouseEvent","copyImage","toBlob","blob","item","ClipboardItem","navigator","clipboard","write","err"],"sources":["src/views/HomeView.vue"],"sourcesContent":["<template>\n  <div\n      style=\"\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      width: 100vw;\n      height: 100vh;\n    \"\n  >\n    <div>\n      <!-- 生成二维码按钮和输入二维码的输入框 -->\n      <input v-model=\"url\" placeholder=\"输入链接\" type=\"text\" />\n      <button @click=\"generateQRCode\">输入网址链接生成二维码</button>\n      <hr />\n\n      <!-- 生成图片主要的容器部分 -->\n      <div\n          class=\"container\"\n          style=\"\n          margin-top: 20px;\n          /* border: 1px solid; */\n          width: 200px;height: 200px;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        \"\n      >\n        <div v-if=\"qrCode\">\n          <img :src=\"qrCode\" style=\"width: 200px;height: 200px;border: 1px #CCCCCC solid;\" alt=\"QR Code\" />\n        </div>\n      </div>\n\n      <!-- 保存图片和复制图片按钮 -->\n      <div\n          style=\"\n          width: 100%;\n          display: flex;\n          justify-content: space-around;\n          align-items: center;\n          height: 100px;\n        \"\n      >\n        <button @click=\"saveImage\">保存图片</button>\n        <button @click=\"copyImage\">复制图片</button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n// yarn add qrcode 执行命令安装\nimport QRCode from \"qrcode\";\n// yarn add html2canvas@1.0.0-rc.4 执行命令安装\nimport html2canvas from \"html2canvas\";\nexport default {\n  data() {\n    return {\n      url: \"\", // 这个是输入框的值\n      qrCode: \"\", // 这个是二维码图片的url\n      base64Image: \"\", // 这个是保存图片和复制图片使用的base64图片地址\n    };\n  },\n  methods: {\n    // 将页面内容生成图片的逻辑\n    generateimages() {\n      // 获取容器元素\n      const container = document.querySelector(\".container\");\n      const that = this;\n      // 使用 html2canvas 生成图片\n      return html2canvas(container, {\n        useCORS: true, // 开启跨域配置\n        allowTaint: false, // 允许跨域图片\n        scale: 2, // 按比例增加分辨率 (2=双倍).\n        dpi: window.devicePixelRatio * 2, // 设备像素比\n        height: document.querySelector('.container').clientHeight + 3, // 预防生成的图片截图不全的问题(例如加填充,边框等,就会导致截图不全,这样适当给截图区域加一点距离)\n      })\n          .then((canvass) => {\n            // 在canvas上添加文字内容准备\n            const title = \"萧寂\";\n            const title2 = \"萧寂的文件分享\";\n            const title3 = \"有效期至: 2024/04/08 23:59:59\";\n\n            // 创建画布\n            const canvas = document.createElement(\"canvas\");\n\n            // 设置 Canvas 元素的宽度和高度,与生成的canvas宽高一致\n            canvas.width = canvass.width;\n            canvas.height = canvass.height;\n\n            // 获取 Canvas 的 2D 绘图上下文\n            const ctx = canvas.getContext(\"2d\");\n            // 设置背景颜色为白色\n            ctx.fillStyle = \"#FFFFFF\";\n            // 创建白色块,宽高等于1画布的宽高\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // 设置圆形的中心位置(x和y轴)\n            var centerX = canvas.width / 2;\n            var centerY = 40;\n\n            // 设置圆形的半径\n            var radius = 30;\n\n            // 绘制圆形\n            ctx.beginPath();\n            // (参数:中心点横坐标,中心点纵坐标,半径,路径(这里是2π代表整个圆),顺时针还是逆时针(由于是一整个圆,就不区分顺时针和逆时针了))\n            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, false);\n            // 圆的填充颜色\n            ctx.fillStyle = \"blue\";\n            ctx.fill();\n\n            // 创建一个图片对象\n            const image = new Image();\n            // 图片对象的src指向生成的图片的base64字符串,通过canvass.toDataURL()获得\n            image.src = canvass.toDataURL();\n\n            // 这里使用了promise,预防异步\n            return new Promise((resolve, reject) => {\n              // 等图片加载完毕\n              image.onload = function () {\n                // 下面三个是获取三个文字的宽\n                const titleWidth = ctx.measureText(title).width;\n                const titleWidth2 = ctx.measureText(title2).width;\n                const titleWidth3 = ctx.measureText(title3).width;\n                // 在 Canvas 上绘制图片(每个参数含义(图片源,横坐标,纵坐标,宽,高))\n                ctx.drawImage(\n                    image,\n                    canvas.width / 2 - canvas.width / 4+5,\n                    canvas.height / 2 - canvas.height / 4+50,\n                    canvas.width / 2,\n                    canvas.height / 2\n                );\n\n                // 绘制其他内容\n                ctx.fillStyle = \"#FFFFFF\"; // 指定文字颜色\n                ctx.font = \"16px Arial\"; // 指定文字字号大小(只需要改前面的数字就行)\n\n                // !!!!注意,下面的文字理论可以通过canvas.width / 2 - titleWidth/ 2直接定位到水平中间的,但是如果画布内容有html内容则也会有影响的,因此这里需要手动调整\n                // 将文字定位到指定位置(参数(文字,横坐标,纵坐标))\n                ctx.fillText(title, (canvas.width / 2 - titleWidth/ 2-6), 45);\n\n                // 指定第二个文字的位置和颜色\n                ctx.fillStyle = \"#000000\"; // 指定文字颜色\n                ctx.font = \"20px Arial\";\n                ctx.fillText(title2, (canvas.width / 2 - titleWidth2), 100);\n\n                // 指定第三个文字的位置和颜色\n                ctx.fillStyle = \"#000000\"; // 指定文字颜色\n                ctx.font = \"13px Arial\";\n                ctx.fillText(title3, (canvas.width / 2 - titleWidth3/2-20), 130);\n\n                // 将 Canvas 转换为 base64 图片并保存\n                console.log(\"canvas.toDataURL()\", canvas.toDataURL());\n                that.base64Image = canvas.toDataURL();\n\n                // 操作完成，resolve Promise\n                resolve(\"完成\");\n              };\n\n              image.onerror = function (error) {\n                // 操作失败，reject Promise\n                reject(error);\n              };\n            });\n          })\n          .catch((error) => {\n            console.error(\"生成图片出错：\", error);\n            throw error;\n          });\n    },\n    generateQRCode() {\n      // 生成二维码逻辑(参数指定url文字即可)\n      QRCode.toDataURL(this.url)\n          .then(async (qr) => {\n            this.qrCode = qr;\n            // 生成完二维码重新对容器的内容进行图片的生成\n            // 这里会有异步情况,建议等一会\n            setTimeout(()=>{\n              this.generateimages()\n            },1000)\n          })\n          .catch((error) => {\n            console.error(\"生成二维码出错：\", error);\n          });\n    },\n    saveImage() {\n      // 保存图片功能\n      // 创建一个虚拟的链接元素\n      const link = document.createElement(\"a\");\n      // 指定a元素href地址(指向base64图片)\n      link.href = this.base64Image;\n      // 下载图片的图片名后缀\n      link.download = \"image.png\";\n\n      // 使用点击事件模拟下载操作\n      link.dispatchEvent(new MouseEvent(\"click\"));\n    },\n    copyImage() {\n      // 实现复制图片到剪贴板的逻辑\n      // 创建一个Image元素并设置src为base64图片\n      const image = new Image();\n      image.src = this.base64Image;\n      console.log(\"复制的图片为:\", this.base64Image);\n      // 等待图片加载完成\n      image.onload = () => {\n        // 创建一个canvas元素\n        const canvas = document.createElement(\"canvas\");\n        // 获取canvas上下文对象\n        const ctx = canvas.getContext(\"2d\");\n\n        // 设置canvas的尺寸与图片一致\n        canvas.width = image.width;\n        canvas.height = image.height;\n\n        // 将图片绘制到canvas上\n        ctx.drawImage(image, 0, 0, image.width, image.height);\n\n        // 调用Clipboard API将canvas内容复制到剪贴板\n        canvas.toBlob((blob) => {\n          const item = new ClipboardItem({ \"image/png\": blob });\n          navigator.clipboard\n              .write([item])\n              .then(() => {\n                console.log(\"图片已复制到剪贴板\");\n              })\n              .catch((err) => {\n                console.error(\"复制图片失败:\", err);\n              });\n        });\n      };\n\n      image.onerror = (err) => {\n        console.error(\"图片加载失败:\", err);\n      };\n    },\n  },\n};\n</script>\n\n<style>\n*{\n  padding: 0;\n  margin: 0;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}